#!/usr/bin/env python3
#------------------------------------------------------------------------------#
#  DFTB+: general package for performing fast atomistic simulations            #
#  Copyright (C) 2006 - 2020  DFTB+ developers group                           #
#                                                                              #
#  See the LICENSE file for terms of usage and distribution.                   #
#------------------------------------------------------------------------------#
#
"""
Calculates the elastic stiffness tensor by finite differences of the stress tensor.
"""
import os
import subprocess
import argparse
import re
import numpy as np
import numpy.linalg as la

BOHR__AA = 0.529177249
AA__BOHR = 1.0 / BOHR__AA
PRESURE_AU = 0.339893208050290E-13 # 1 Pa in atomic units of pressure

DESCRIPTION = """
Calculates Cijkl tensor in the Voight form, C_\alpha\beta, using the
specified DFTB+ binary and applying finite difference strain
displacements to the reference geometry. The geometry of the
configuration must be specified in a file called
'geo.gen.template'. The DFTB+ input file should include the geometry
from the file 'geo.gen'. The input file must specify the option for
writing an autotest file and the option for calculating the forces, as
this also outputs the stress tensor. The lattice vectors should be
fixed in the dftb_in.hsd file, but the atom positions (internal
coordinates) can either be clamped or relaxed depending on which is
required.
"""

STRESS_PATTERN = re.compile(r"stress\s*:[^:]*:[^:]*:3,3\n\s*(?P<value11>\S+)\s+(?P<value21>\S+)\s+(?P<value31>\S+)\n\s*(?P<value12>\S+)\s+(?P<value22>\S+)\s+(?P<value32>\S+)\n\s*(?P<value13>\S+)\s+(?P<value23>\S+)\s+(?P<value33>\S+)\n")

def main():
    """Main routine"""

    args = parse_arguments()
    specienames, species, coords, origin, latvecs = readgen("geo.gen.template")
    disp = args.disp * AA__BOHR
    binary = args.binary
    print("BINARY:", binary)

    elastic = calculate_elastic(
        binary, disp, coords, latvecs, specienames, species, origin)

    print_elastic(elastic)


def parse_arguments():
    """Parses command line arguments"""

    parser = argparse.ArgumentParser(description=DESCRIPTION)

    msg = "Specify the displacement of the atoms (unit: ANGSTROM)"
    parser.add_argument("-d", "--displacement", type=float, dest="disp",
                        default=1e-5, help=msg)

    msg = "DFTB+ binary"
    parser.add_argument("binary", help=msg)

    args = parser.parse_args()
    return args


def calculate_elastic(binary, disp, coords, latvecs, specienames, species,
                        origin):
    """Calculates elastic constants by finite differences"""

    # to hold stress tensor
    stress = np.empty((6, 2), dtype=float)
    # to hold resulting elastic tensor
    elastic = np.empty((6,6), dtype=float)

    # voight convention for 2 index to 1 of tensors
    voight = [[0,0],[1,1],[2,2],[1,2],[0,2],[0,1]]

    for ii in range(6):
        for kk in range(2):
            strain = np.zeros((3,3), dtype = float)
            for jj in range (3) :
                strain[jj][jj] = 1.0
            strain[voight[ii][0]][voight[ii][1]] += 0.5*float(2 * kk - 1) * disp
            strain[voight[ii][1]][voight[ii][0]] += 0.5*float(2 * kk - 1) * disp
            newcoords = np.array(coords)
            newcoords = cart2frac(latvecs,newcoords)
            newvecs = np.array(latvecs)
            newvecs = np.dot(newvecs,strain)
            newcoords = frac2cart(newvecs,newcoords)
            writegen("geo.gen", (specienames, species, newcoords, origin, newvecs))
            subprocess.call([binary,])
            fp = open("autotest.tag", "r")
            txt = fp.read()
            fp.close()
            match = STRESS_PATTERN.search(txt)
            if match:
                stress[0,kk] = float(match.group("value11"))
                stress[1,kk] = float(match.group("value22"))
                stress[2,kk] = float(match.group("value33"))
                stress[3,kk] = 0.5*float(match.group("value23"))
                stress[3,kk] += 0.5*float(match.group("value32"))
                stress[4,kk] = 0.5*float(match.group("value13"))
                stress[4,kk] += 0.5*float(match.group("value31"))
                stress[5,kk] = 0.5*float(match.group("value12"))
                stress[5,kk] += 0.5*float(match.group("value21"))
            else:
                raise "No match found!"
            for jj in range(6):
                elastic[ii][jj] = (stress[jj][0] - stress[jj][1]) / (2.0 * disp)

    return elastic


def print_elastic(elastic):
    """Prints calculated elastic constants."""

    for ii in range(6):
        for jj in range(6):
            elastic[ii][jj] /= (PRESURE_AU * 1.0E9) # Convert to GPa
    print("\nElastic constants (GPa):")
    for ii in range(6):
        print (("%12.4f"*6) % tuple(elastic[ii]))


def readgen(fname):
    """Reads in the content of a gen file."""

    fp = open(fname, "r")
    line = fp.readline()
    words = line.split()
    natom = int(words[0])
    periodic = (words[1] == 'S' or words[1] == 's')
    fractional = (words[1] == 'F' or words[1] == 'f')
    if not (periodic or fractional):
        raise "Structure must be periodic!"
    line = fp.readline()
    specienames = line.split()
    coords = np.empty((natom, 3), dtype=float)
    species = np.empty(natom, dtype=int)
    for ii in range(natom):
        line = fp.readline()
        words = line.split()
        species[ii] = int(words[1]) - 1
        coords[ii] = (float(words[2]), float(words[3]), float(words[4]))
    line = fp.readline()
    origin = np.array([float(s) for s in line.split()], dtype=float)
    latvecs = np.empty((3, 3), dtype=float)
    for ii in range(3):
        line = fp.readline()
        latvecs[ii] = [float(s) for s in line.split()]
    if fractional:
        coords = frac2cart(latvecs, coords)
    origin *= AA__BOHR
    latvecs *= AA__BOHR
    coords *= AA__BOHR
    return specienames, species, coords, origin, latvecs


def writegen(fname, data):
    """Writes the geometry as gen file."""

    fp = open(fname, "w")
    specienames, species, coords, origin, latvecs = data
    fp.write("%5d %s\n" % (len(coords), latvecs is None and "C" or "S"))
    fp.write(("%2s "*len(specienames) + "\n") % tuple(specienames))
    coords = coords * BOHR__AA
    for ii in range(len(coords)):
        fp.write("%5d %5d %23.15E %23.15E %23.15E\n"
                 % (ii + 1, species[ii] + 1, coords[ii, 0], coords[ii, 1],
                    coords[ii, 2]))
    if latvecs is not None:
        origin = origin * BOHR__AA
        latvecs = latvecs * BOHR__AA
        fp.write("%23.15E %23.15E %23.15E\n" % tuple(origin))
        for ii in range(3):
            fp.write("%23.15E %23.15E %23.15E\n" % tuple(latvecs[ii]))
    fp.close()


def cart2frac(latvecs, coords):
    "Converts cartesian coordinates to fractional coordinates."

    invlatvecs = np.empty((3, 3), dtype=float)
    invlatvecs = np.transpose(latvecs)
    newcoords = np.array(coords)
    invlatvecs = la.inv(invlatvecs)
    for iat, atcoords in enumerate(coords):
        newcoords[iat] = np.dot(invlatvecs, atcoords)
    return newcoords


def frac2cart(latvecs, coords):
    """Converts fractional coordinates to cartesian ones."""

    newcoords = np.array(coords)
    for iat, atcoords in enumerate(coords):
        newcoords[iat] = np.dot(np.transpose(latvecs), atcoords)
    return newcoords


def stress2latderivs(stress, latvecs):
    """Converts stress to lattice derivatives."""

    invlatvecs = la.inv(latvecs)
    volume = la.det(latvecs)
    latderivs = -volume * np.transpose(np.dot(stress, invlatvecs))
    return latderivs


if __name__ == "__main__":
    main()
